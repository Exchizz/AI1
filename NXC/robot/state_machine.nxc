// Defines
#define THRESHOLD1 35 // light sensor threshold
#define THRESHOLD2 30

#define P 1
#define I 0.000025
#define D 100

// PID line follower parameters
int actual_position;
int error;
int previous_error;

int proportional;
int integral;
int derivative;
int result;

int right;
int left;
int speed = 50;

int dt = 25;

// Sensors
int sensor_1; // Line follower
int sensor_2; // Line follower
int sensor_3; // Segment sensor

// states
int STATE = 1; // initialized as READ_COMMAND
#define READ_COMMAND 1
#define TURN_RIGHT 2
#define TURN_LEFT 3
#define REVERSE 4
#define LINE_FOLLOW 5
#define LINE_FOLLOW_SHORT 6


// substates
int substate;
#define RIGHT 7
#define LEFT 8


int i = 0;        // iterator in plan
int prev_count;   // prev count check integer (iterator)

// READ_COMMAND variables, previous, current and next command in plan
char prev;
char curr;
char next;

// bools for line following
bool line_follow_short = false;
bool linefollow_12_reached = false;
bool linefollow_3_reached = false;


// the master plan
string plan = "UURLDU";


task main(){

  while(true){
    SetSensorLight(IN_1); // Line follower
    SetSensorLight(IN_2); // Line follower
    SetSensorLight(IN_3); // Segment sensor

    sensor_1 = Sensor(IN_1);
    sensor_2 = Sensor(IN_2);
    sensor_3 = Sensor(IN_3);

    switch(STATE){
      case READ_COMMAND:
        prev_count = (i-1 > 0 ? i -1 : 0);

        prev = plan[prev_count];
        curr = plan[i];
        next = plan[i+1];

        switch (prev) {
          case 'U':
            switch (curr) {
              case 'U':
                STATE = LINE_FOLLOW;
              break;

              case 'D':
                STATE = REVERSE;
              break;

              case 'L':
                STATE = TURN_LEFT;
              break;

              case 'R':
                STATE = TURN_RIGHT;
              break;
            }
          break;

          case 'D':
            switch (curr) {
              case 'U':
                STATE = REVERSE;
              break;

              case 'D':
                STATE = LINE_FOLLOW;
              break;

              case 'L':
                STATE = TURN_RIGHT;
              break;

              case 'R':
                STATE = TURN_LEFT;
              break;
            }
          break;

          case 'L':
          switch (curr) {
            case 'U':
              STATE = TURN_RIGHT;
            break;

            case 'D':
              STATE = TURN_LEFT;
            break;

            case 'L':
              STATE = LINE_FOLLOW;
            break;

            case 'R':
              STATE = REVERSE;
            break;
          }
          break;

          case 'R':
          switch (curr) {
            case 'U':
              STATE = TURN_LEFT;
            break;

            case 'D':
              STATE = TURN_RIGHT;
            break;

            case 'L':
              STATE = REVERSE;
            break;

            case 'R':
              STATE = LINE_FOLLOW;
            break;
          }

          break;
        }

        i++;
        break;

        case TURN_RIGHT:
          if(line_follow_short){
            RotateMotorEx(OUT_AB, 40, 165, 100, true, true); // old turn 140, new 150
            line_follow_short = false;
            STATE = LINE_FOLLOW;
          }
          substate = RIGHT;
          STATE = LINE_FOLLOW_SHORT;
          break;

        case TURN_LEFT:
          if(line_follow_short){
            RotateMotorEx(OUT_AB, 40, 165, -100, true, true); // old turn 140, new 150
            line_follow_short = false;
            STATE = LINE_FOLLOW;
          }
          substate = LEFT;
          STATE = LINE_FOLLOW_SHORT;
          break;

        case REVERSE:
        // backwards linefollow with sensor_1 & 2 as stopsensor. , rotates 180 degrees sets STATE = READ_COMMAND;

          linefollow_3_reached = false;
          previous_error = error;
          while (!linefollow_3_reached) {

            SetSensorLight(IN_1); // Line follower
            SetSensorLight(IN_2); // Line follower
            SetSensorLight(IN_3); // Segment sensor

            sensor_1 = Sensor(IN_1);
            sensor_2 = Sensor(IN_2);
            sensor_3 = Sensor(IN_3);


            error = sensor_1 - sensor_2;

            proportional = P * error;
            integral = I + error;
            derivative = (error - previous_error) / dt;

            result = proportional + I * dt * integral + D * derivative;

            previous_error = error;

            left = speed + result;                        // adjust left wheel
            right = speed - result;                       // adjust right wheel

              // Adjust the left and right motor value.
             if (left >   100) left  =  100;
             if (left <  -100) left  = -100;
             if (right >  100) right =  100;
             if (right < -100) right = -100;


            if (left < 0 )                              // check direction (OnFwd statement can't have negative input)
              {
                 OnFwd(OUT_A,-left);  //OnFwd(OUT_A,-left);
               }
             else
               {
                 OnRev(OUT_A,left); //OnRev(OUT_A,left);
               }


             if (right < 0 )                              // check direction (OnFwd statement cann't have negative input)
               {
                 OnFwd(OUT_B,-right); //OnFwd(OUT_B,-right);
               }
              else
                {
                  OnRev(OUT_B,right); //OnRev(OUT_B,right);
                }

             if (sensor_1 < THRESHOLD1 && sensor_2 < THRESHOLD1) {
                  linefollow_3_reached = true;
                  Wait(150);
                  OnFwdSync(OUT_AB,0,0);
                }
             Wait(dt);
          }
          RotateMotorEx(OUT_AB, 40, 160, -100, true, true);
          STATE = READ_COMMAND;


          break;

        case LINE_FOLLOW:
        // PID controller for forward line follow, stops at sensor 1 & 2 < THRESHOLD1

          linefollow_12_reached = false;
          previous_error = error;
          while (!linefollow_12_reached) {

            SetSensorLight(IN_1); // Line follower
            SetSensorLight(IN_2); // Line follower
            SetSensorLight(IN_3); // Segment sensor

            sensor_1 = Sensor(IN_1);
            sensor_2 = Sensor(IN_2);
            sensor_3 = Sensor(IN_3);

            error = sensor_1 - sensor_2;

            proportional = P * error;
            integral = I + error;
            derivative = (error - previous_error) / dt;

            result = proportional + I * dt * integral + D * derivative;

            previous_error = error;

            left = speed - result;                        // adjust left wheel
            right = speed + result;                       // adjust right wheel

              // Adjust the left and right motor value.
             if (left >   100) left  =  100;
             if (left <  -100) left  = -100;
             if (right >  100) right =  100;
             if (right < -100) right = -100;


            if (left < 0 )                              // check direction (OnFwd statement can't have negative input)
              {
                 OnFwd(OUT_A,-left);  //OnFwd(OUT_A,-left);
               }
             else
               {
                 OnRev(OUT_A,left); //OnRev(OUT_A,left);
               }


             if (right < 0 )                              // check direction (OnFwd statement cann't have negative input)
               {
                 OnFwd(OUT_B,-right); //OnFwd(OUT_B,-right);
               }
              else
                {
                  OnRev(OUT_B,right); //OnRev(OUT_B,right);
                }

             if (sensor_1 < THRESHOLD1 && sensor_2 < THRESHOLD1) {
                  linefollow_12_reached = true;
                  Wait(150);
                  OnFwdSync(OUT_AB,0,0);
                }
             Wait(dt);
          }

          STATE = READ_COMMAND;
          break;

        case LINE_FOLLOW_SHORT:
        // PID controller for forward line follow, stops at sensor 3 < THRESHOLD2

          linefollow_3_reached = false;
          previous_error = error;
          while (!linefollow_3_reached) {

            SetSensorLight(IN_1); // Line follower
            SetSensorLight(IN_2); // Line follower
            SetSensorLight(IN_3); // Segment sensor

            sensor_1 = Sensor(IN_1);
            sensor_2 = Sensor(IN_2);
            sensor_3 = Sensor(IN_3);

            error = sensor_1 - sensor_2;

            proportional = P * error;
            integral = I + error;
            derivative = (error - previous_error) / dt;

            result = proportional + I * dt * integral + D * derivative;

            previous_error = error;

            left = speed - result;                        // adjust left wheel
            right = speed + result;                       // adjust right wheel

              // Adjust the left and right motor value.
             if (left >   100) left  =  100;
             if (left <  -100) left  = -100;
             if (right >  100) right =  100;
             if (right < -100) right = -100;


            if (left < 0 )                              // check direction (OnFwd statement can't have negative input)
              {
                 OnFwd(OUT_A,-left); // OnFwd(OUT_A,-left);
               }
             else
               {
                 OnRev(OUT_A,left); // OnRev(OUT_A,left);
               }


             if (right < 0 )                              // check direction (OnFwd statement can't have negative input)
               {
                 OnFwd(OUT_B,-right); //OnFwd(OUT_B,-right);
               }
              else
                {
                  OnRev(OUT_B,right); //OnRev(OUT_B,right);
                }

             if (sensor_3 < THRESHOLD2) {
                  linefollow_3_reached = true;
                  Wait(150);
                  OnFwdSync(OUT_AB,0,0);
                }
             Wait(dt);
          }

            switch(substate){
              case LEFT:
                line_follow_short = true;
                STATE = TURN_LEFT;
                break;

              case RIGHT:
                line_follow_short = true;
                STATE = TURN_RIGHT;
                break;
            }
          break;
          }
    }
}
