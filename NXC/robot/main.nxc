

// Defines
#define THRESHOLD1 40 // light sensor threshold
#define THRESHOLD2 35

// Sensors
int sensor_1; // Line follower
int sensor_2; // Line follower
int sensor_3; // Segment sensor


// Variables

string plan; // declared solution array of max 500 elements
char lastmove; // last move variable, should be P
char current;

int len;


// Bools
bool intersection_reached = false; // Bool for segment reached
bool busy = false; // Bool for indicating whether a task is busy doing a move.
bool line_follow = false; // Bool for checking line follow.

bool turn_right = false;
bool turn_left = false;
bool turn_complete = false;

//bool reverse = false; // Bool for reverse movement


//-----------------------------------------------------------------------------
//------------------------------Line follower----------------------------------
sub follow_line(char lastmove, char current, bool busy){

// Default case, first element in solution array
  if(lastmove == 'P'){
    lastmove = current;
  line_follow = true;
  }

  switch(current){
    case 'U':
        if(lastmove == 'U'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;

    case 'D':
        if(lastmove == 'D'){
          line_follow = true;

        }
        else
          line_follow = false;
      break;

    case 'L':
        if(lastmove == 'L'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;
    case 'R':
        if(lastmove == 'R'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;

    default:
      break;
  }



if(line_follow && busy == false){
  busy = true;

  	while(intersection_reached == false){

      SetSensorLight(IN_1); // Line follower
      SetSensorLight(IN_2); // Line follower
      SetSensorLight(IN_3); // Segment sensor

      sensor_1 = Sensor(IN_1);
      sensor_2 = Sensor(IN_2);
      sensor_3 = Sensor(IN_3);

        if (sensor_3 < THRESHOLD2){
          intersection_reached = true;
          Wait(150);
          OnFwdSync(OUT_AB, 0, 0);
        }

  		  else if(sensor_1 > THRESHOLD1 && sensor_2 > THRESHOLD1){
  			  OnFwdSync(OUT_AB, 50, 0);

  		  }

        else if(sensor_1 > THRESHOLD1){
          OnFwd(OUT_A, 0);
          OnFwd(OUT_B, 35);

        }

        else if(sensor_2 > THRESHOLD1){
        	OnFwd(OUT_B, 0);
        	OnFwd(OUT_A, 35);

        }
    }
  busy = false;
  intersection_reached = false;
  }
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//-----------------------------------turn--------------------------------------
sub turn(char lastmove, char current, bool busy){


// Pseudo code for switch statement for turning
//SetSensorLight(IN_1); // Line follower
//SetSensorLight(IN_2); // Line follower
//SetSensorLight(IN_3); // Segment sensor


  switch(lastmove){

    case 'U':
        if(current == 'R'){
          // turn right orientation wise
          turn_right = true;
        }
        else if(current == 'L'){
          // turn left orientation wise
          turn_left = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }

        break;

    case 'D':
        if(current == 'R'){
          // turn left orientation wise
          turn_left = true;
        }
        else if(current == 'L'){
          // turn right orientation wise
          turn_right = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }

        break;

    case 'L':
        if(current == 'U'){
          // turn left orientation wise
          turn_right = true;
        }
        else if(current == 'D'){
          // turn right orientation wise
          turn_left = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }

        break;

    case 'R':
        if(current == 'U'){
          // turn right orientation wise
          turn_left = true;
        }
        else if(current == 'D'){
          //turn left orientation wise
          turn_right = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }

        break;

    default:
        break;
  }

  if((turn_left || turn_right) && busy == false){
    busy = true;
    while(!turn_complete) {

      SetSensorLight(IN_1); // Line follower
      SetSensorLight(IN_2); // Line follower
      SetSensorLight(IN_3); // Segment sensor

      sensor_1 = Sensor(IN_1);
      sensor_2 = Sensor(IN_2);
      sensor_3 = Sensor(IN_3);

      if(sensor_1 > THRESHOLD1 && sensor_2 > THRESHOLD1){
        OnFwdSync(OUT_AB, 50, 0);
      }

      else if(sensor_1 > THRESHOLD1){
        OnFwd(OUT_A, 0);
        OnFwd(OUT_B, 35);
      }

      else if (sensor_1 < THRESHOLD1 && sensor_2 < THRESHOLD1) {
        OnFwdSync(OUT_AB, 0, 0);

        if (turn_right) {
          // Initial Guess of 90 degrees turn
          RotateMotorEx(OUT_AB, 25, 180, 100, true, true);

          turn_complete = true;
        }

        else if (turn_left) {
          // Initial Guess of 90 degrees turn
          RotateMotorEx(OUT_AB, 25, 180, 100, true, true);

          turn_complete = true;
        }
      }
    }
    busy = false;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//----------------------------------Reverse------------------------------------
//void reverse(char last, char current, bool busy){

//switch(last){

//  case "U":
//    if(current == "D"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;
//    break;

//  case "D":
//    if (current == "U"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;

//    break;

//  case "L":
//    if(current == "R"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;
//    break;

//  case "R":
//    if(current == "L"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;
//    break;

//  default:
//    break;
//}


// Code for reverse movement....
//if(reverse && busy == false){


//  if(sensor_1 > THRESHOLD){
//    OnFwd(OUT_B, 0);
//    OnFwd(OUT_A, 60);
//  }

//  if(sensor_2 > THRESHOLD){
//    OnFwd(OUT_A, 0);
//    OnFwd(OUT_B, 60);
//  }

//}



//}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

// remember first case, when lastmove = null

//-----------------------------------------------------------------------------
//---------------------------------Main Task-----------------------------------
//-----------------------------------------------------------------------------
task main(){

     plan="DD";
     lastmove = 'D';
     len =  ArrayLen(plan);

        for (int i=0; i < len; i++)
        {

          follow_line(lastmove, plan[i], busy);
          turn(lastmove, plan[i], busy);

        //reverse(lastmove ,solution[i], busy);
          lastmove = plan[i];

        }
      }
