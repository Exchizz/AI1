

// Defines
#define THRESHOLD1 40 // light sensor threshold
#define THRESHOLD2 35

// Sensors
int sensor_1; // Line follower
int sensor_2; // Line follower
int sensor_3; // Segment sensor
string plan; // declared solution array of max 500 elements
char lastmove; // last move variable, should be P
char current;

int len;

// Variables


// Bools
bool intersection_reached = false; // Bool for segment reached
bool busy = false; // Bool for indicating whether a task is busy doing a move.
bool line_follow = false; // Bool for checking line follow.
//bool reverse = false; // Bool for reverse movement


//-----------------------------------------------------------------------------
//------------------------------Line follower----------------------------------
sub follow_line(char lastmove, char current, bool busy){

// Default case, first element in solution array
  if(lastmove == 'P'){
    lastmove = current;
  line_follow = true;
  }

  switch(current){
    case 'U':
        if(lastmove == 'U'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;

    case 'D':
        if(lastmove == 'D'){
          line_follow = true;

        }
        else
          line_follow = false;
      break;

    case 'L':
        if(lastmove == 'L'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;
    case 'R':
        if(lastmove == 'R'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;

    default:
      break;
  }



if(line_follow && busy == false){

  	while(intersection_reached == false){

      SetSensorLight(IN_1); // Line follower
      SetSensorLight(IN_2); // Line follower
      SetSensorLight(IN_3); // Segment sensor

      sensor_1 = Sensor(IN_1);
      sensor_2 = Sensor(IN_2);
      sensor_3 = Sensor(IN_3);

        busy = true;

        if (sensor_3 < THRESHOLD2){
          intersection_reached = true;
          Wait(150);
          OnFwdSync(OUT_AB, 0, 0);
        }

  		  else if(sensor_1 > THRESHOLD1 && sensor_2 > THRESHOLD1){
  			  OnFwdSync(OUT_AB, 50, 0);

  		  }


        else if(sensor_1 > THRESHOLD1){
          OnFwd(OUT_A, 0);
          OnFwd(OUT_B, 35);

        }


        else if(sensor_2 > THRESHOLD1){
        	OnFwd(OUT_B, 0);
        	OnFwd(OUT_A, 35);

        }
        // No active breaking, the bang-bang line follower stops when this sensor
        // hits the intersection.
    }
  busy = false;
  //Wait(500);
  intersection_reached = false;
  }
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//-----------------------------------turn--------------------------------------
//void turn(char last, char current, bool busy){


// Pseudo code for switch statement for turning
//SetSensorLight(IN_1); // Line follower
//SetSensorLight(IN_2); // Line follower
//SetSensorLight(IN_3); // Segment sensor





//switch(last){

//  case "U":
//      if(current == "R"){
        // turn right orientation wise
//        busy = true;
//      }
//      else if(current == "L"){
        // turn left orientation wise
//        busy = true;
//      }

//      break;

//  case "D":
//      if(current == "R"){
        // turn left orientation wise
//        busy = true;
//      }
//      else if(current == "L"){
        // turn right orientation wise
//        busy = true;
//      }

//      break;

//  case "L":
//      if(current == "U"){
        // turn left orientation wise
//        busy = true;
//      }
//      else if(current == "D"){
        // turn right orientation wise
//        busy = true;
//      }

//      break;

//  case "R":
//      if(current == "U"){
        // turn right orientation wise
//        busy = true;
//      }
//      else if(current == "D"){
        //turn left orientation wise
//        busy = true;
//      }

//      break;

//  default:
//    break;
//}



//}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//----------------------------------Reverse------------------------------------
//void reverse(char last, char current, bool busy){

//switch(last){

//  case "U":
//    if(current == "D"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;
//    break;

//  case "D":
//    if (current == "U"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;

//    break;

//  case "L":
//    if(current == "R"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;
//    break;

//  case "R":
//    if(current == "L"){
//      reverse = true;  // perform reverse movement
//      busy = true;
//    }
//    else
//      reverse = false;
//    break;

//  default:
//    break;
//}


// Code for reverse movement....
//if(reverse && busy == false){


//  if(sensor_1 > THRESHOLD){
//    OnFwd(OUT_B, 0);
//    OnFwd(OUT_A, 60);
//  }

//  if(sensor_2 > THRESHOLD){
//    OnFwd(OUT_A, 0);
//    OnFwd(OUT_B, 60);
//  }

//}



//}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

// remember first case, when lastmove = null

//-----------------------------------------------------------------------------
//---------------------------------Main Task-----------------------------------
//-----------------------------------------------------------------------------
task main(){
      //rtn_code_1 = OpenFileRead("solution.txt", fsize, handle); // Loads the solution from the solver


      ////----------------File Open Check-----------------
      //if(rtn_code_1 != LDR_SUCCES){
      //  TextOut(0, LCD_LINE1, "File Open Failed     ");
      //  shutdown(SEC_8);
      //  }

      ////-------Read from file into solution string-------
      //rtn_code_2 = Read(handle, solution);
      //SetSensorLight(IN_1); // Line follower
      //SetSensorLight(IN_2); // Line follower
      //SetSensorLight(IN_3); // Segment sensor

      //hile(true){
      //TextOut(0, LCD_LINE1, NumToStr(SensorValue(IN_2)));
     //}
      //----------------File Read Check------------------
      //if(rtn_code_2 == LDR_SUCCES){
     plan="DD";
     lastmove = "D";
     len =  ArrayLen(plan);

        for (int i=0; i < len; i++)
        {

          follow_line(lastmove, plan[i], busy);

        //turn(lastmove ,solution[i], busy);
        //reverse(lastmove ,solution[i], busy);


          lastmove = plan[i];

        }

      //else{
        //TextOut(0, LCD_LINE1, "File Read Failed     ");
      //  shutdown(SEC_8);
      //}
      //}
}
