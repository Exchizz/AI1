

// Defines
#define THRESHOLD1 40 // light sensor threshold
#define THRESHOLD2 35

// Sensors
int sensor_1; // Line follower
int sensor_2; // Line follower
int sensor_3; // Segment sensor


// Variables

string plan; // declared solution array of max 500 elements
char lastmove; // last move variable, should be P
char current;

int len;


string test;


// Bools
bool intersection_reached = false; // Bool for segment reached
bool busy = false; // Bool for indicating whether a task is busy doing a move.
bool line_follow = false; // Bool for checking line follow.

bool turn_right = false;
bool turn_left = false;
bool turn_complete = false;

//bool reverse = false; // Bool for reverse movement


//-----------------------------------------------------------------------------
//------------------------------Line follower----------------------------------
sub follow_line(char lastmove, char current, bool busy){

// Default case, first element in solution array
  if(lastmove == 'P'){
    lastmove = current;
  line_follow = true;
  }

  switch(current){
    case 'U':
        if(lastmove == 'U'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;

    case 'D':
        if(lastmove == 'D'){
          line_follow = true;

        }
        else
          line_follow = false;
      break;

    case 'L':
        if(lastmove == 'L'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;
    case 'R':
        if(lastmove == 'R'){
          line_follow = true;

          }
        else
          line_follow = false;
      break;

    default:
      break;
  }



if(line_follow && busy == false){


  	while(intersection_reached == false){

      SetSensorLight(IN_1); // Line follower
      SetSensorLight(IN_2); // Line follower
      SetSensorLight(IN_3); // Segment sensor

      sensor_1 = Sensor(IN_1);
      sensor_2 = Sensor(IN_2);
      sensor_3 = Sensor(IN_3);

      busy = true;

        if (sensor_3 < THRESHOLD2){
          intersection_reached = true;
          Wait(150);
          OnFwdSync(OUT_AB, 0, 0);
        }

  		  else if(sensor_1 > THRESHOLD1 && sensor_2 > THRESHOLD1){
  			  OnFwdSync(OUT_AB, 50, 0);

  		  }

        else if(sensor_1 > THRESHOLD1){
          OnFwd(OUT_A, 0);
          OnFwd(OUT_B, 35);

        }

        else if(sensor_2 > THRESHOLD1){
        	OnFwd(OUT_B, 0);
        	OnFwd(OUT_A, 35);

        }
    }
  busy = false;
  intersection_reached = false;
  }
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//-----------------------------------turn--------------------------------------
sub turn(char lastmove, char current, bool busy){

  switch(lastmove){
    case 'U':
        if(current == 'R'){
          // turn right orientation wise
          turn_right = true;
        }
        else if(current == 'L'){
          // turn left orientation wise
          turn_left = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }

        break;
    case 'D':
        if(current == 'R'){
          // turn left orientation wise
          turn_left = true;
        }
        else if(current == 'L'){
          // turn right orientation wise
          turn_right = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }
        break;
    case 'L':
        if(current == 'U'){
          // turn left orientation wise
          turn_right = true;
        }
        else if(current == 'D'){
          // turn right orientation wise
          turn_left = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }

        break;

    case 'R':
        if(current == 'U'){
          // turn right orientation wise
          turn_left = true;
        }
        else if(current == 'D'){
          //turn left orientation wise
          turn_right = true;
        }
        else{
          turn_left = false;
          turn_right = false;
        }

        break;

    default:
        break;
  }

  if((turn_left || turn_right) && busy == false){

    while(!turn_complete) {
      busy = true;

      SetSensorLight(IN_1); // Line follower
      SetSensorLight(IN_2); // Line follower
      SetSensorLight(IN_3); // Segment sensor

      sensor_1 = Sensor(IN_1);
      sensor_2 = Sensor(IN_2);
      sensor_3 = Sensor(IN_3);

      if(sensor_1 > THRESHOLD1 && sensor_2 > THRESHOLD1){
        OnFwdSync(OUT_AB, 50, 0);
      }

      else if(sensor_1 > THRESHOLD1){
        OnFwd(OUT_A, 0);
        OnFwd(OUT_B, 35);
      }

      else if (sensor_1 < THRESHOLD1 && sensor_2 < THRESHOLD1) {
        OnFwdSync(OUT_AB, 0, 0);

            if (turn_right) {
              TextOut(0,LCD_LINE1, "turn right");
              Wait(1000);
              // Initial Guess of 90 degrees turn
              RotateMotorEx(OUT_AB, 25, 140, 100, true, true);
            }

            else if (turn_left) {
              TextOut(0,LCD_LINE2, "turn left");
              Wait(1000);
              // Initial Guess of 90 degrees turn
              RotateMotorEx(OUT_AB, 25, 140, -100, true, true);
            }
            // Line follow to next segment
            if (sensor_3 < THRESHOLD2){
              turn_complete = true;
              Wait(150);
              OnFwdSync(OUT_AB, 0, 0);
            }

      		  else if(sensor_1 > THRESHOLD1 && sensor_2 > THRESHOLD1){
      			  OnFwdSync(OUT_AB, 50, 0);
      		  }

            else if(sensor_1 > THRESHOLD1){
              OnFwd(OUT_A, 0);
              OnFwd(OUT_B, 35);
            }

            else if(sensor_2 > THRESHOLD1){
            	OnFwd(OUT_B, 0);
            	OnFwd(OUT_A, 35);
            }
      }
    }
    busy = false;
    turn_left = false;
    turn_right = false;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//----------------------------------Reverse------------------------------------
//sub reverse(char last, char current, bool busy){

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//---------------------------------Main Task-----------------------------------
//-----------------------------------------------------------------------------
task main(){

     plan = "URUR";
     lastmove = 'P';

     if(StrIndex(plan,0) == 'U')
      lastmove = 'U';
     else if(StrIndex(plan,0) == 'D')
      lastmove = 'D';
     else if(StrIndex(plan,0) == 'R')
      lastmove = 'R';
     else if(StrIndex(plan,0) == 'L')
      lastmove = 'L';

    //string test = " ";

    len =  ArrayLen(plan);

        for (int i=0; i < len; i++)
        {

          follow_line(lastmove, plan[i], busy);
          turn(lastmove, plan[i], busy);

        //reverse(lastmove ,solution[i], busy);

        //test[0] = StrIndex(plan,i);
        //if (StrIndex(plan,0) == 'U')
        // TextOut(0,LCD_LINE3,"test");
        //Wait(1000);

          lastmove = plan[i];

        }
      }
